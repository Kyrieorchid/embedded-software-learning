***

###### 重写printf()

​	printf()底层调用write()，重写write()定向到串口输出。

***

###### ADC_Sensor

​	集成了传感器和ADC模块，相当于简单的应用了ADC的系统，如集成了热敏原件和ADC_Converter的温度Sensor，可以直观读出温度数据。

***

##### `__attribute__`

​	`__attribute__` 是GNU编译器 (GCC) 提供的一个扩展，用来设置函数、变量、类型的特殊属性。这些属性可以用来优化代码、控制代码生成、增强代码检查等。

​	语法：`__attribute__((attribute-list))`

​	`__attribute__((packed))`:取消结构体内存对齐，使其紧凑排列。

​	`__attribute__((weak))`:声明弱符号属性，用于全局变量和函数，若存在 *<u>同名强符号</u>* 变量或函数则可以覆盖。

***

###### GDB&GCC&GNU

​	GNU（GNU's Not Unix）项目的目标是开发一个与Unix兼容的操作系统，提供完全自由的软件工具和应用程序。（开发了许多工具和软件，但它缺少一个重要的部分：操作系统内核。GNU工具与Linux内核结合，形成了一个完整的操作系统，通常被称为GNU/Linux。

​	GCC（GNU Compiler Collection）是一个编译器集合，支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada等。**Tips**：预处理（生成**.i**文件）-> 编译（生成**.s**汇编文件）-> 汇编（生成**.o**二进制目标文件）-> 链接（生成**.exe**可执行文件）。[GCC命令](https://blog.csdn.net/qq_39872252/article/details/133309120)

​	GDB（GNU Debugger）：调试器，单步执行、断点和检查变量值等功能。

​	GNU Make：需要`Makefile`文件来描述编译和链接规则，`make`命令会按`Makefile`的内容编译与链接。

***

###### DMA

​	

***

###### 大小端模式

​	大端模式是指数据的高字节存储在低地址处，低字节存储在高地址处。即数据的最高有效字节（MSB, Most Significant Byte）存储在内存的最低地址。

​	小端模式是指数据的低字节存储在低地址处，高字节存储在高地址处。即数据的最低有效字节（LSB, Least Significant Byte）存储在内存的最低地址。

***

###### Shallow Copy & Deep Copy

​	<u>浅拷贝</u>：浅拷贝创建一个新的对象，但并不复制对象内部的子对象，而是将引用拷贝过来。因此，浅拷贝后的对象与原对象共享相同的子对象。

​	<u>深拷贝</u>：深拷贝创建一个新的对象，并递归地复制所有子对象。因此，深拷贝后的对象与原对象完全独立，修改一个对象不会影响另一个对象。

​	![image-20240716184341475](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240716184341475.png)

​	切片操作（即`[:]`）相当于浅拷贝，而不是深拷贝。全切片操作复制的是引用，而不是实际的子对象，因此，修改原对象中的可变子对象会影响到新对象中的对应子对象。

​	<u>当对一个简单的一维数组（如 `[1, 2, 3, 4]`）进行浅拷贝时,因为一维数组的元素是不可变类型（如整数），在浅拷贝过程中，复制的是这些元素的引用，但由于它们是不可变的，直接修改会创建一个新的对象，而不会影响原对象。</u>

***

###### const假只读

const只是修饰变量，不能通过变量名直接操作对应内存，可通过指针修改const定义的变量。

`const uint8 a = 10; *(uint8*)(&a) = 11;`

***

###### 数组指针

定义了一个数组 `uint8 a[8] = {0}; uint8 *b = a;`，此时，`&a` 和 `&b` 有区别：

1. `&a` 表示的是整个数组 `a` 的地址。数组名 `a` 在表达式中通常会退化为指向其第一个元素的指针（`*b = a`就是），<u>但在取地址操作符 `&` 前面，`a` 表示整个数组</u>，`&a` 得到的是数组 `a` 的地址，类型是 `uint8 (*)[8]`。
2. `&b` 表示的是指针 `b` 的地址。指针 `b` 是一个指针变量，存储了数组 `a` 的地址（`*b = a`中a就表示首元素地址），`&b` 得到的是指针 `b` 自身的地址，类型是 `uint8 **`。

关键在于a在`uint8 *b = a`中就表示首元素地址，b就是二级指针；在`&a`中a就表示整个数组，&a就是数组的一级指针。

***

###### LIN break field

LIN通信中，break字段通常为连续至少13位低电平，用于标识帧的开始、唤醒从节点。从节点需要能够检测和解析到break字段，但通常<u>不需要特别配置从节点break字段长度</u>，其硬件和驱动程序能够检测和响应标准的break字段。

***

###### BIT0清0

将register的bit0清零时，`reg &= 0`会将reg全清零，`reg &= ~1`。

***

###### TCM紧密耦合存储器

TCM通常直接连接到CPU，访问延迟非常低，通常在一个时钟周期内完成读写操作，但容量较小。这使得TCM非常适合存储需要高性能访问的数据或代码，如中断向量表、时间关键任务的代码和数据。

TCM的使用需要程序员显式分配和管理，通常通过特定的<u>编译器</u>指令或<u>链接器脚本</u>进行控制，明确哪些数据或代码段放入TCM中。

***

###### void*指针

又叫通用指针，没有具体的指向数据类型，不能直接解引用。可以被强制转换为需要的具体类型的指针再解引用。

动态内存分配函数（如`malloc`）返回`void`指针，可以分配任意类型的数据。

![image-20240808115727682](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240808115727682.png)

可以使用`void`指针作为函数参数，实现对不同类型数据的操作。

![image-20240808115819249](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240808115819249.png)

***

###### 内存对齐

内存对齐是指将数据放置在特定的地址边界上，使得CPU可以高效地访问数据。对于大小为N字节的数据类型，对齐要求其地址是N的倍数。

结构体对齐：



***

###### 链接脚本

`.ld`链接脚本文件使用的是一种特定于GNU链接器（GNU linker，简称`ld`）的脚本语言，用于控制链接器在生成<u>可执行文件或其他可链接目标文件（如库文件）</u>时的行为和布局。使用LLVM工具链，仍然可以使用GNU `ld`脚本，但需要注意LLD的某些特性和限制。

***

###### CAN_FIFO & MailBox

FIFO在配置好接受滤波器后，所有通过滤波的消息会顺序存储在缓冲区，只能按照先进先出来处理；MB可以配置为收发特定ID的消息，还可以根据ID手动配置优先级，不必按顺序处理。
FIFO适用于处理大量顺序性强、优先级要求不高的普通消息，而邮箱更适用于对消息有严格控制需求的场景，如需要优先处理的关键消息。

***

###### RAM分区分段

分段是分区的一种形式，内存分区将内存划分为代码区、数据区和栈区，而分段则具体定义了这些区域的用途和结构，比如数据区按照是否初始化具体分为`.data`和`.bss`段。
常见RAM分段：栈区Stack、堆区Heap、已初始化数据段data、未初始化数据段bss、文本段text（存放程序的机器代码和常量字符串，尽管这部分通常存储在ROM或Flash中，但某些情况下如自修改代码，也可能部分加载到RAM中）、内存映射I/O段和保留段。
统一编制的情况下RAM中的内存映射段：在一些高端MCU或复杂的SoC中，可能存在专门的内存区域，这些区域与特定的外设或硬件功能绑定。例如，高速缓存或专用加速器的控制寄存器可能会被映射到RAM的特定段中，方便快速访问。一些MCU会在RAM的地址空间中为调试或系统监控保留特定的内存区域，这些区域可能会映射到一些特殊寄存器或状态控制器，便于开发人员进行低层次的系统调试和分析。

*** 

###### 大小端与ASCII

以字节打印整数时考虑平台大小端。字符串被编码为以null字符结尾的字符数组，以ASCII码存储时与平台字节顺序和字大小规则无关，thus文本数据比二进制数据更具平台独立性。

***

###### startup与bootloader

`startup.s`用于初始化MCU硬件状态，将系统从复位状态带到可运行C代码的状态，主要操作包括设置SP、复制data到RAM、清空RAM中的bss和设置中断向量表等。
Bootloader是一种更高级别的启动代码，它的功能更复杂多样：
* 引导应用程序：Bootloader的主要任务是从ROM加载应用程序代码到RAM中，并启动执行。这对于允许用户更新或选择不同应用程序尤其有用。
* 固件更新：Bootloader通常支持通过串口、USB、网络或其他接口更新固件。这使得系统可以在无需物理接触的情况下升级软件(OTA)。
* 系统自检：有些Bootloader会在启动时执行硬件自检或其他诊断任务，以确保系统在一个健康的状态下启动。
* 安全启动：有些高级Bootloader还负责实现安全启动功能，如验证固件的签名，以防止加载未经授权的代码。

二者的区别：
* `startup.s`相对简单且固定，通常由芯片厂商提供，并不经常修改。Bootloader则可以根据项目需求进行定制，具有很大的灵活性。

***

##### 