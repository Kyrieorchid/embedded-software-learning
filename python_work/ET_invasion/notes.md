# 存储浮点数但访问整数的用途

## 1. 允许内部精确计算
虽然 `x` **对外表现为整数**，但 `_x` **内部存储的是浮点数**，这样可以保持更精确的计算，避免累积误差。例如：

```python
rect = FloatRect(10.2, 20.5, 100, 50)
rect.x += 1.7  # 计算过程：10.2 + 1.7 = 11.9
rect.x += 1.7  # 计算过程：11.9 + 1.7 = 13.6
print(rect.x)  # 输出 13，而不是 12（累积误差减少）
```
如果 `x` 直接存 `int`，每次加 `1.7` 时都会截断为 `1`，造成误差累积。

---

## 2. 适用于 `pygame.Rect` 这样的整数坐标系统
在 `pygame` 中，`Rect` 的 `x` 只能是整数（因为像素坐标必须是整数），但有时候你需要 **平滑移动对象**，而 `float` 存储可以实现更精确的位移计算：

```python
class FloatRect:
    def __init__(self, x: float, y: float, w: int, h: int):
        self._x = x
        self._y = y
        self.w = w
        self.h = h

    @property
    def x(self):
        return int(self._x)  # 取整以匹配 pygame.Rect

    @x.setter
    def x(self, value):
        self._x = value  # 内部仍然存储 float

rect = FloatRect(10.2, 20.5, 100, 50)

# 模拟小幅移动
rect.x += 0.7
rect.x += 0.7
rect.x += 0.7

print(rect.x)  # 输出 12，而不是 11（保留了浮点数运算的精确度）
```
如果 `x` 直接存 `int`，则：
- `10 + 0.7` → `10`
- `10 + 0.7` → `10`
- `10 + 0.7` → `10`
一直是 `10`，小数部分全丢失。

但如果存 `float`，计算过程是：
- `10.2 + 0.7` → `10.9`
- `10.9 + 0.7` → `11.6`
- `11.6 + 0.7` → `12.3`
最后 `print(rect.x)` **输出 `12`，比 `10` 更接近真实位置**。

---

## 3. 防止 UI / 物理计算误差
在 **物理仿真、游戏、动画等场景**，对象的位置常常以浮点数计算，但绘制时只能使用整数像素。例如：
- **存储 `float`**，保持物体在 **逻辑上的真实位置**。
- **访问时返回 `int`**，确保渲染时在 **屏幕像素对齐**，防止模糊抖动。

示例：
```python
# 物理引擎中的物体位置
rect._x = 99.999999  # 存储 float，保持高精度
print(rect.x)  # 显示 99，不会在屏幕上出现小数像素导致抖动
```

---

## 4. 适用于定点数计算
在一些嵌入式系统或老游戏引擎中，不支持 `float` 运算，但可以使用 **浮点数存储 + 访问时取整** 来模拟 **定点数计算**，提高效率。

---

## 结论
存储浮点数但访问整数 **最适合用于需要高精度计算但最终显示/存储时必须是整数的场景**，比如：
- **游戏中的坐标（pygame.Rect）**
- **物理仿真**
- **定点数计算**
- **UI 渲染，避免像素抖动**
- **金融计算（保留精确值，显示整数部分）**

✅ **你可以存储更高精度的数据，而不会影响外部使用的整数限制。**

